# 'variables' for user interface
SELECTED_FRAME:
    .word 0xFF000000
CANVAS_WIDTH:
    .half 320
CANVAS_HEIGHT:
    .half 240

# 'variables'
.eqv STC_BLOCK 0
.eqv DYN_BLOCK 1
.eqv SPRITE_STRUCT_SIZE 616
.eqv SPRITE_IMAGE_SIZE_STRUCT_SIZE 300

MAP_MATRIX_SIZE:
    .half 300 # area of the map in sprites: width * height (20 * 15)

# we use this two variables to correctly
# assess which sprites need to be re-rendered
LOLO_POSITION_CURRENT_X:
    .half 200
LOLO_POSITION_CURRENT_Y:
    .half 200
LOLO_POSITION_LAST_X:
    .half 68
LOLO_POSITION_LAST_Y:
    .half 32
LOLO_HIDDED_BLOCK:
    .word ground

# we will use this variable to store the sprite that was
# hidden by lolo when it moved
HIDDEN_SPRITE:
    .word 16, 16
    .space 256 # 256 = 16*16 (the size in bytes for one sprite)

DYN_BLOCK_SPRITE_CURR_X:
    .space 16
DYN_BLOCK_SPRITE_CURR_Y:
    .space 16
DYN_BLOCK_SPRITE_NEXT_X:
    .space 16
DYN_BLOCK_SPRITE_NEXT_Y:
    .space 16
DYN_BLOCK_SPRITE_ADDRESS:
    .space 32
DYN_BLOCK_SPRITE:
    .word 16, 16
    .space 256 # 256 = 16*16 (the size in bytes for one sprite)

# this variable is responsible to store the pointer to the
# struct_array, struct_array's lenght and also it's capacity
# a similar aproach is used by Rust, and is the reference used
# to this implementation
# see this link for a diagram representation of the data:
# https://i.imgur.com/OaNWzRN.png
DYN_VECT_STRUCT:
    .space 4 # pointer to struct_array
    .space 4 # length
    .space 4 # capacity

#==============================
RETURN_ADDRESS_INITIALIZE_LOLO:
    .space 4

#==============================
MOVE_DYNAMIC_SPRITE_ARG_A0: .space 4
MOVE_DYNAMIC_SPRITE_ARG_A1: .space 4
MOVE_DYNAMIC_SPRITE_ARG_A2: .space 4
MOVE_DYNAMIC_SPRITE_ARG_A3: .space 4
RETURN_ADDRESS_MOVE_DYNAMIC_SPRITE: .space 4
#==============================

#==============================
RETURN_ADDRESS_DYNAMIC_SPRITE_PRINT_HIDDEN_SPRITE:  .space 4
#==============================

#==============================
RETURN_ADDRESS_DYNAMIC_SPRITE_SAVE_NEXT_DYN_SPRITE:  .space 4
#==============================

#==============================
RETURN_ADDRESS_DYNAMIC_SPRITE_UPDATE_CURRENT_POSITION:  .space 4
#==============================

#==============================
RETURN_ADDRESS_DYNAMIC_SPRITE_UPDATE_NEXT_POSITION:  .space 4
#==============================

#==============================
RETURN_ADDRESS_CONVERT_RELATIVE_TO_ABSOLUTE_MOVE:   .space 4
#==============================

#==============================
RETURN_ADDRESS_MOVE_LOLO:   .space 4
MOVE_LOLO_ADDRESS_TO_DATA:   .space 4
#==============================

#==============================
RETURN_ADDRESS_KEYBOARD_INPUT:  .space 4
#==============================

#==============================
RETURN_ADDRESS_CAN_LOLO_MOVE:  .space 4
#==============================

#==============================
RETURN_ADDRESS_CAN_LOLO_MOVE_GLITCH:    .space 4
#==============================

#==============================
    # each of this variables store the address for the next sprite and the ID of the last printed sprite
LOLO_U: .space 4
.space 4
LOLO_L: .space 4
.space 4
LOLO_N: .space 4
.space 4
LOLO_R: .space 4
.space 4
#==============================

#==============================
RETURN_ADDRESS_INITIALIZE_DYNAMIC_SPRITE:   .space 4
INITIALIZE_DYNAMIC_SPRITE_POSITION_CURRENT_X:   .space 2
INITIALIZE_DYNAMIC_SPRITE_POSITION_CURRENT_Y:   .space 2
INITIALIZE_DYNAMIC_SPRITE_DYNAMIC_SPRITE_INDEX_IN_STRUCT_ARRAY: .space 4
INITIALIZE_DYNAMIC_SPRITE_ADDRESS_TO_DYNAMIC_SPRITE_DATA:   .space 4
INITIALIZE_DYNAMIC_SPRITE_COLLIDE:   .space 4
#==============================

#==============================
RETURN_ADDRESS_WILL_COLLIDE_WITH_DYNAMIC_SPRITE: .space 4
RETURN_ADDRESS_GET_COLLIDE_FIELD: .space 4
RETURN_ADDRESS_LOOP_THROUGH_DYNAMIC_SPRITES:    .space 4
GET_COLLIDE_FIELD_A0: .space 4
WILL_COLLIDE_WITH_DYNAMIC_SPRITE_A0:  .space 4
#==============================

#==============================
# Counter of lolo lifes
LOLO_LIFE:    .space 4 # Creating a byte space for th variable of lifes
.eqv LOLO_LIFE_X 272 # x of where to print the number
.eqv LOLO_LIFE_Y 64 # Y of where to print the number

# Constant numberss
.eqv LOLO_LIFE_TOTAL 5
.eqv LOLO_LIFE_4 4
.eqv LOLO_LIFE_3 3
.eqv LOLO_LIFE_2 2
.eqv LOLO_LIFE_1 1
.eqv LOLO_LIFE_0 0

RETURN_ADDRESS_LOLO_LIFE_PRINT: .space 4
#==============================

#==============================
RETURN_ADDRESS_READ_CASTLE_DYNAMIC_MAP: .space 4
#==============================

#==============================
LOLO_MOVEMENT_DYNAMIC_MAP:  .space 4
#==============================

#==============================
READ_AND_PRINT_MAP_MATRIX_DYNAMIC_SPRITES_A0:   .space 4
READ_AND_PRINT_MAP_MATRIX_DYNAMIC_SPRITES_A1:   .space 4
RETURN_ADDRESS_READ_AND_PRINT_MAP_MATRIX_DYNAMIC_SPRITES:   .space 4
#==============================

#==============================
UPDATE_SPRITE_ANIMATION_NEXT_SPRITE_ADDRESS:    .space 4
UPDATE_SPRITE_ANIMATION_CURRENT_DIRECTION:    .word 0
UPDATE_SPRITE_ANIMATION_CURRENT_FRAME:    .word 0 #// current frame is one of [0,1,2,3] because we have only 4 animated sprites for each direction
#==============================
