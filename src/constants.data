# 'variables' for user interface
SELECTED_FRAME:
    .word 0xFF000000
CANVAS_WIDTH:
    .half 320
CANVAS_HEIGHT:
    .half 240

# 'variables'
.eqv STC_BLOCK 0
.eqv DYN_BLOCK 1
.eqv SPRITE_STRUCT_SIZE 612
.eqv SPRITE_IMAGE_SIZE_STRUCT_SIZE 300

MAP_MATRIX_SIZE:
    .half 300 # area of the map in sprites: width * height (20 * 15)

# we use this two variables to correctly
# assess which sprites need to be re-rendered
LOLO_POSITION_CURRENT_X:
    .half 200
LOLO_POSITION_CURRENT_Y:
    .half 200
LOLO_POSITION_LAST_X:
    .half 68
LOLO_POSITION_LAST_Y:
    .half 32
LOLO_HIDDED_BLOCK:
    .word ground

# we will use this variable to store the sprite that was
# hidden by lolo when it moved
HIDDEN_SPRITE:
    .word 16, 16
    .space 256 # 256 = 16*16 (the size in bytes for one sprite)

DYN_BLOCK_SPRITE_CURR_X:
    .space 16
DYN_BLOCK_SPRITE_CURR_Y:
    .space 16
DYN_BLOCK_SPRITE_NEXT_X:
    .space 16
DYN_BLOCK_SPRITE_NEXT_Y:
    .space 16
DYN_BLOCK_SPRITE_ADDRESS:
    .space 32
DYN_BLOCK_SPRITE:
    .word 16, 16
    .space 256 # 256 = 16*16 (the size in bytes for one sprite)

# this variable is responsible to store the pointer to the
# struct_array, struct_array's lenght and also it's capacity
# a similar aproach is used by Rust, and is the reference used
# to this implementation
# see this link for a diagram representation of the data:
# https://i.imgur.com/OaNWzRN.png
DYN_VECT_STRUCT:
    .space 4 # pointer to struct_array
    .space 4 # length
    .space 4 # capacity

#==============================
RETURN_ADDRESS_INITIALIZE_LOLO:
    .space 4

#==============================
MOVE_DYNAMIC_SPRITE_ARG_A0: .space 4
MOVE_DYNAMIC_SPRITE_ARG_A1: .space 4
MOVE_DYNAMIC_SPRITE_ARG_A2: .space 4
MOVE_DYNAMIC_SPRITE_ARG_A3: .space 4
RETURN_ADDRESS_MOVE_DYNAMIC_SPRITE: .space 4
#==============================

#==============================
RETURN_ADDRESS_DYNAMIC_SPRITE_PRINT_HIDDEN_SPRITE:  .space 4
#==============================

#==============================
RETURN_ADDRESS_DYNAMIC_SPRITE_SAVE_NEXT_DYN_SPRITE:  .space 4
#==============================

#==============================
RETURN_ADDRESS_DYNAMIC_SPRITE_UPDATE_CURRENT_POSITION:  .space 4
#==============================

#==============================
RETURN_ADDRESS_DYNAMIC_SPRITE_UPDATE_NEXT_POSITION:  .space 4
#==============================

#==============================
RETURN_ADDRESS_CONVERT_RELATIVE_TO_ABSOLUTE_MOVE:   .space 4
#==============================

#==============================
RETURN_ADDRESS_MOVE_LOLO:   .space 4
MOVE_LOLO_ADDRESS_TO_DATA:   .space 4
#==============================

#==============================
RETURN_ADDRESS_KEYBOARD_INPUT:  .space 4
#==============================

#==============================
RETURN_ADDRESS_CAN_LOLO_MOVE:  .space 4
#==============================

#==============================
RETURN_ADDRESS_CAN_LOLO_MOVE_GLITCH:    .space 4
#==============================

#==============================
    # each of this variables store the address for the next sprite and the ID of the last printed sprite
LOLO_U: .space 4
.space 4
LOLO_L: .space 4
.space 4
LOLO_N: .space 4
.space 4
LOLO_R: .space 4
.space 4
#==============================
